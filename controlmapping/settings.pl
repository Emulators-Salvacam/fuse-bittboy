#!/usr/bin/perl -w

# settings.pl: generate controlmappingsettings.c from settings.dat
# Copyright (c) 2020 Pedro Luis Rodríguez González

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# Author contact information:

# E-mail: pl.rguez@gmail.com

use strict;

use Fuse;

sub hashline ($) { '#line ', $_[0] + 1, '"', __FILE__, "\"\n" }

my %options;

while(<>) {

    next if /^\s*$/;
    next if /^\s*#/;

    chomp;

    my( $name, $type, $default, $short, $commandline, $configfile ) =
	split /\s*,\s*/;

    if( ( not defined $commandline ) || ( $commandline eq '' ) ) {
	$commandline = $name;
	$commandline =~ s/_/-/g;
    }

    if( ( not defined $configfile ) || ( $configfile eq '' ) ) {
	$configfile = $commandline;
	$configfile =~ s/-//g;
    }


    next if !($name =~ /^joystick/);

    $options{$name} = { type => $type, default => $default, short => $short,
			commandline => $commandline,
			configfile => $configfile };
}

print Fuse::GPL( 'controlmappingsettings.c: Handling control mapping settings',
		 '2002 Philip Kendall & 2020 Pedro Luis RodrÃ­guez GonzÃ¡lez' );

print hashline( __LINE__ ), << 'CODE';

/* This file is autogenerated from settings.dat by settings.pl.
   Do not edit unless you know what will happen! */

#include <config.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#ifdef HAVE_GETOPT_LONG		/* Did our libc include getopt_long? */
#include <getopt.h>
#elif defined AMIGA || defined __MORPHOS__            /* #ifdef HAVE_GETOPT_LONG */
/* The platform uses GNU getopt, but not getopt_long, so we get
   symbol clashes on this platform. Just use getopt */
#else				/* #ifdef HAVE_GETOPT_LONG */
#include "compat.h"		/* If not, use ours */
#endif				/* #ifdef HAVE_GETOPT_LONG */

#ifdef HAVE_LIB_XML2
#include <libxml/xmlmemory.h>
#include <libxml/parser.h>
#endif				/* #ifdef HAVE_LIB_XML2 */

#include "fuse.h"
#include "infrastructure/startup_manager.h"
#include "machine.h"
#include "controlmapping/controlmappingsettings.h"
#include "settings.h"
#include "spectrum.h"
#include "ui/ui.h"
#include "utils.h"

/* The current control mappings */
control_mapping_info control_mapping_current;
control_mapping_info control_mapping_default;
control_mapping_info control_mapping_default_old;

char *defaultmapfile = NULL;

#ifdef HAVE_LIB_XML2
static int control_mapping_parse_xml( xmlDocPtr doc, control_mapping_info *control_mapping );
#else				/* #ifdef HAVE_LIB_XML2 */
static int control_mapping_parse_ini( utils_file *file, control_mapping_info *control_mapping );
#endif				/* #ifdef HAVE_LIB_XML2 */

static void control_mapping_copy_internal( control_mapping_info *dest, control_mapping_info *src );
static void control_mapping_copy_from_settings_internal( control_mapping_info *dest, settings_info *src );
static void control_mapping_copy_to_settings_internal( settings_info *dest, control_mapping_info *src );
static void control_mapping_end( void );

const char* re_expressions[] = {
    "(([[:space:]]|[-_])*)(([[]|[(])+[[:space:]]*)(([[:alnum:]]|[[:space:]]|[[:punct:]])*)([[:space:]]*([]]|[)])+)(([[:space:]]|[-_])*)",
    "(([[:space:]]|[-_])*)(([(]|[[])*[[:space:]]*)(disk|tape|side|part|release)(([[:space:]]|[[:punct:]])*)(([abcd1234])([[:space:]]*of[[:space:]]*[1234])*)([[:space:]]*([)]|[]])*)(([[:space:]]|[-_])*)",
    "(([[:space:]]|[-_])*)((128k|48k)+)(([[:space:]]|[-_])*)",
    "(([[:space:]]|[-_])*)((small|medium|large)[[:space:]]*[[:alnum:]]*[[:space:]]*case)(([[:space:]]|[-_])*)",
    NULL };

/* Fill the control mapping structure with sensible defaults */
void control_mapping_defaults( control_mapping_info *control_mapping )
{
  control_mapping_copy_internal( control_mapping, &control_mapping_default );
}

#ifdef HAVE_LIB_XML2

/* Read control mappings from the mapping file (if libxml2 is available) */

int
control_mapping_read_config_file( control_mapping_info *control_mapping, const char *filename )
{
  xmlDocPtr doc;

  /* If don't have file to load there is no error */
  if ( !filename ) return 1;

  /* See if the file exists, if don't there is no error */
  if( !compat_file_exists( filename ) ) return 1;

  doc = xmlReadFile( filename, NULL, 0 );
  if( !doc ) {
    ui_error( UI_ERROR_ERROR, "error reading mapping controls file" );
    return 1;
  }

  if( control_mapping_parse_xml( doc, control_mapping ) ) {
    xmlFreeDoc( doc );
    return 1;
  }

  xmlFreeDoc( doc );

  return 0;
}

static int
control_mapping_parse_xml( xmlDocPtr doc, control_mapping_info *control_mapping )
{
  xmlNodePtr node;
  xmlChar *xmlstring;

  node = xmlDocGetRootElement( doc );
  if( xmlStrcmp( node->name, (const xmlChar*)"control_mapping" ) ) {
    ui_error( UI_ERROR_ERROR, "control_mapping file's root node is not 'control_mapping'" );
    return 1;
  }

  node = node->xmlChildrenNode;
  while( node ) {

CODE

foreach my $name ( sort keys %options ) {

    my $type = $options{$name}->{type};

    if( $type eq 'boolean' or $type eq 'numeric' ) {

	print << "CODE";
    if( !strcmp( (const char*)node->name, "$options{$name}->{configfile}" ) ) {
      xmlstring = xmlNodeListGetString( doc, node->xmlChildrenNode, 1 );
      if( xmlstring ) {
        control_mapping->$name = atoi( (char*)xmlstring );
        xmlFree( xmlstring );
      }
    } else
CODE

    } elsif( $type eq 'string' ) {

	    print << "CODE";
    if( !strcmp( (const char*)node->name, "$options{$name}->{configfile}" ) ) {
      xmlstring = xmlNodeListGetString( doc, node->xmlChildrenNode, 1 );
      if( xmlstring ) {
        libspectrum_free( control_mapping->$name );
        control_mapping->$name = utils_safe_strdup( (char*)xmlstring );
        xmlFree( xmlstring );
      }
    } else
CODE

    } elsif( $type eq 'null' ) {

	    print << "CODE";
    if( !strcmp( (const char*)node->name, "$options{$name}->{configfile}" ) ) {
      /* Do nothing */
    } else
CODE

    } else {
	die "Unknown setting type `$type'";
    }
}

print hashline( __LINE__ ), << 'CODE';
    if( !strcmp( (const char*)node->name, "text" ) ) {
      /* Do nothing */
    } else {
      ui_error( UI_ERROR_WARNING, "Unknown setting '%s' in control mapping file",
		node->name );
    }

    node = node->next;
  }

  return 0;
}

int
control_mapping_write_config( control_mapping_info *control_mapping, const char *filename )
{
  char buffer[80];

  xmlDocPtr doc; xmlNodePtr root;

  /* If don't have file to save do nothing */
  if ( !filename ) return 0;

  /* Create the XML document */
  doc = xmlNewDoc( (const xmlChar*)"1.0" );

  root = xmlNewNode( NULL, (const xmlChar*)"control_mapping" );
  xmlDocSetRootElement( doc, root );
CODE

foreach my $name ( sort keys %options ) {

    my $type = $options{$name}->{type};

    if( $type eq 'boolean' ) {

	print "  xmlNewTextChild( root, NULL, (const xmlChar*)\"$options{$name}->{configfile}\", (const xmlChar*)(control_mapping->$name ? \"1\" : \"0\") );\n";

    } elsif( $type eq 'string' ) {
	print << "CODE";
  if( control_mapping->$name )
    xmlNewTextChild( root, NULL, (const xmlChar*)"$options{$name}->{configfile}", (const xmlChar*)control_mapping->$name );
CODE
    } elsif( $type eq 'numeric' ) {
	print << "CODE";
  snprintf( buffer, 80, "%d", control_mapping->$name );
  xmlNewTextChild( root, NULL, (const xmlChar*)"$options{$name}->{configfile}", (const xmlChar*)buffer );
CODE
    } elsif( $type eq 'null' ) {
	# Do nothing
    } else {
	die "Unknown setting type `$type'";
    }
}

  print hashline( __LINE__ ), << 'CODE';

  xmlSaveFormatFile( filename, doc, 1 );

  xmlFreeDoc( doc );

  return 0;
}

#else				/* #ifdef HAVE_LIB_XML2 */

/* Read control mapping from the config file as ini file (if libxml2 is not available) */

int
control_mapping_read_config_file( control_mapping_info *control_mapping, const char *filename )
{
  int error;

  utils_file file;

  /* If don't have file to load there is no error */
  if ( !filename ) return 1;

  /* See if the file exists; if doesn't, it's not a problem */
  if( !compat_file_exists( filename ) ) return 1;

  error = utils_read_file( filename, &file );
  if( error ) {
    ui_error( UI_ERROR_ERROR, "error reading control mapping file" );
    return 1;
  }

  if( control_mapping_parse_ini( &file, control_mapping ) ) { utils_close_file( &file ); return 1; }

  utils_close_file( &file );

  return 0;
}

static int
control_mapping_var( control_mapping_info *control_mapping, unsigned char *name, unsigned char *last,
              int **val_int, char ***val_char, unsigned char **next  )
{
  unsigned char* cpos;
  size_t n;

  *val_int = NULL;
  *val_char = NULL;

  *next = name;
  while( name < last && ( *name == ' ' || *name == '\t' || *name == '\r' ||
                          *name == '\n' ) ) {
    *next = ++name;					/* seek to first char */
  }
  cpos = name;

  while( cpos < last && ( *cpos != '=' && *cpos != ' ' && *cpos != '\t' &&
                          *cpos != '\r' && *cpos != '\n' ) ) cpos++;
  *next = cpos;
  n = cpos - name;		/* length of name */

  while( *next < last && **next != '=' ) {		/* search for '=' */
    if( **next != ' ' && **next != '\t' && **next != '\r' && **next != '\n' )
      return 1;	/* error in value */
    (*next)++;
  }
  if( *next < last) (*next)++;		/* set after '=' */
/*  ui_error( UI_ERROR_WARNING, "Config: (%5s): ", name ); */

CODE
my %type = ('null' => 0, 'boolean' => 1, 'numeric' => 1, 'string' => 2 );
foreach my $name ( sort keys %options ) {
    my $len = length $options{$name}->{configfile};

    print << "CODE";
  if( n == $len && !strncmp( (const char *)name, "$options{$name}->{configfile}", n ) ) {
CODE
    print "    *val_int = \&control_mapping->$name;\n" if( $options{$name}->{type} eq 'boolean' or $options{$name}->{type} eq 'numeric' );
    print "    *val_char = \&control_mapping->$name;\n" if( $options{$name}->{type} eq 'string' );
    print "/*    *val_null = \&control_mapping->$name; */\n" if( $options{$name}->{type} eq 'null' );
    print << "CODE";
    return 0;
  }
CODE
}
    print << "CODE";
  return 1;
}

static int
control_mapping_parse_ini( utils_file *file, control_mapping_info *control_mapping )
{
  unsigned char *cpos, *cpos_new;
  int *val_int;
  char **val_char;

  cpos = file->buffer;

  /* Read until the end of file */
  while( cpos < file->buffer + file->length ) {
    if( control_mapping_var( control_mapping, cpos, file->buffer + file->length, &val_int,
                      &val_char, &cpos_new ) ) {
      /* error in name or something else ... */
      cpos = cpos_new + 1;
      ui_error( UI_ERROR_WARNING,
                "Unknown and/or invalid setting '%s' in control mapping file", cpos );
      continue;
    }
    cpos = cpos_new;
    if( val_int ) {
	*val_int = atoi( (char *)cpos );
	while( cpos < file->buffer + file->length && 
		( *cpos != '\\0' && *cpos != '\\r' && *cpos != '\\n' ) ) cpos++;
    } else if( val_char ) {
	char *value = (char *)cpos;
	size_t n = 0;
	while( cpos < file->buffer + file->length && 
		( *cpos != '\\0' && *cpos != '\\r' && *cpos != '\\n' ) ) cpos++;
	n = (char *)cpos - value;
	if( n > 0 ) {
	  if( *val_char != NULL ) {
	    libspectrum_free( *val_char );
	    *val_char = NULL;
	  }
	  *val_char = libspectrum_new( char, n + 1 );
	  (*val_char)[n] = '\\0';
	  memcpy( *val_char, value, n );
	}
    }
    /* skip 'new line' like chars */
    while( ( cpos < ( file->buffer + file->length ) ) &&
           ( *cpos == '\\r' || *cpos == '\\n' ) ) cpos++;

CODE
print hashline( __LINE__ ), << 'CODE';
  }

  return 0;
}

static int
control_mapping_file_write( compat_fd fd, const char *buffer, size_t length )
{
  return compat_file_write( fd, (const unsigned char *)buffer, length );
}

static int
control_mapping_string_write( compat_fd doc, const char* name, const char* config )
{
  if( config != NULL &&
      ( control_mapping_file_write( doc, name, strlen( name ) ) ||
        control_mapping_file_write( doc, "=", 1 ) ||
        control_mapping_file_write( doc, config, strlen( config ) ) ||
        control_mapping_file_write( doc, FUSE_EOL, strlen( FUSE_EOL ) ) ) )
    return 1;
  return 0;
}

static int
control_mapping_numeric_write( compat_fd doc, const char* name, int config )
{
  char buffer[80]; 
  snprintf( buffer, sizeof( buffer ), "%d", config );
  return control_mapping_string_write( doc, name, buffer );
}

int
control_mapping_write_config( control_mapping_info *control_mapping, const char *filename )
{
  compat_fd doc;

  /* If don't have file to save do nothing */
  if ( !filename ) return 0;

  doc = compat_file_open( filename, 1 );
  if( doc == COMPAT_FILE_OPEN_FAILED ) {
    ui_error( UI_ERROR_ERROR, "couldn't open `%s' for writing: %s\n",
	      filename, strerror( errno ) );
    return 1;
  }

CODE

foreach my $name ( sort keys %options ) {

    my $type = $options{$name}->{type};
    my $len = length "$options{$name}->{configfile}";

    if( $type eq 'boolean' ) {

	print << "CODE";
  if( control_mapping_boolean_write( doc, "$options{$name}->{configfile}",
                              control_mapping->$name ) )
    goto error;
CODE

    } elsif( $type eq 'string' ) {
	print << "CODE";
  if( control_mapping_string_write( doc, "$options{$name}->{configfile}",
                             control_mapping->$name ) )
    goto error;
CODE

    } elsif( $type eq 'numeric' ) {
	print << "CODE";
  if( control_mapping_numeric_write( doc, "$options{$name}->{configfile}",
                              control_mapping->$name ) )
    goto error;
CODE

    } elsif( $type eq 'null' ) {
	# Do nothing
    } else {
	die "Unknown setting type `$type'";
    }
}

  print hashline( __LINE__ ), << 'CODE';

  compat_file_close( doc );

  return 0;
error:
  compat_file_close( doc );

  return 1;
}

#endif				/* #ifdef HAVE_LIB_XML2 */

/* Compare two control mapping options */
int
control_mapping_something_changed( control_mapping_info *dest, settings_info *src )
{
CODE

foreach my $name ( sort keys %options ) {

    my $type = $options{$name}->{type};

    if( $type eq 'boolean' or $type eq 'numeric' ) {
	print "  if ( dest->$name != src->$name ) return 1;\n";
    } elsif( $type eq 'string' ) {
        print << "CODE";
  if ( ( src->$name && !dest->$name ) ||
       ( !src->$name && dest->$name ) ||
       ( src->$name && dest->$name && strcmp( src->$name, dest->$name ) ) )
    return 1;
CODE
    }
}

print << "CODE";
  return 0;
}

/* Copy one custom mapping object to another */
static void
control_mapping_copy_internal( control_mapping_info *dest, control_mapping_info *src )
{
  control_mapping_free( dest );

CODE

foreach my $name ( sort keys %options ) {

    my $type = $options{$name}->{type};

    if( $type eq 'boolean' or $type eq 'numeric' ) {
	print "  dest->$name = src->$name;\n";
    } elsif( $type eq 'string' ) {
	print << "CODE";
  dest->$name = NULL;
  if( src->$name ) {
    dest->$name = utils_safe_strdup( src->$name );
  }
CODE
    }
}

print hashline( __LINE__ ), << 'CODE';
}

/* Copy one control mapping object to settings */
static void
control_mapping_copy_to_settings_internal( settings_info *dest, control_mapping_info *src )
{
  control_mapping_settings_free( dest );

CODE

foreach my $name ( sort keys %options ) {

    my $type = $options{$name}->{type};

    if( $type eq 'boolean' or $type eq 'numeric' ) {
	print "  dest->$name = src->$name;\n";
    } elsif( $type eq 'string' ) {
	print << "CODE";
  dest->$name = NULL;
  if( src->$name ) {
    dest->$name = utils_safe_strdup( src->$name );
  }
CODE
    }
}

print hashline( __LINE__ ), << 'CODE';
}

/* Copy one settings object to control mapping */
static void
control_mapping_copy_from_settings_internal( control_mapping_info *dest, settings_info *src )
{
  control_mapping_free( dest );

CODE

foreach my $name ( sort keys %options ) {

    my $type = $options{$name}->{type};

    if( $type eq 'boolean' or $type eq 'numeric' ) {
	print "  dest->$name = src->$name;\n";
    } elsif( $type eq 'string' ) {
	print << "CODE";
  dest->$name = NULL;
  if( src->$name ) {
    dest->$name = utils_safe_strdup( src->$name );
  }
CODE
    }
}

print hashline( __LINE__ ), << 'CODE';
}

/* Copy one control mapping object to another */
void control_mapping_copy( control_mapping_info *dest, control_mapping_info *src )
{
  control_mapping_defaults( dest );
  control_mapping_copy_internal( dest, src );
}

/* Copy one settings object to control mapping */
void control_mapping_copy_from_settings( control_mapping_info *dest, settings_info *src )
{
  control_mapping_copy_from_settings_internal( dest, src );
}

/* Copy one control mapping object to settings */
void control_mapping_copy_to_settings( settings_info *dest, control_mapping_info *src )
{
  control_mapping_copy_to_settings_internal( dest, src );
}

void
control_mapping_set_string( char **string_setting, const char *value )
{
  /* No need to do anything if the two strings are in fact the
     same pointer */
  if( *string_setting == value ) return;

  if( *string_setting ) libspectrum_free( *string_setting );
  *string_setting = utils_safe_strdup( value );
}

int
control_mapping_free( control_mapping_info *control_mapping )
{
CODE

foreach my $name ( sort keys %options ) {
    if( $options{$name}->{type} eq 'string' ) {
	print "  if( control_mapping->$name ) libspectrum_free( control_mapping->$name );\n";
    }
}

print hashline( __LINE__ ), << 'CODE';

  return 0;
}

int
control_mapping_settings_free( settings_info *settings )
{
CODE

foreach my $name ( sort keys %options ) {
    if( $options{$name}->{type} eq 'string' ) {
	print "  if( settings->$name ) libspectrum_free( settings->$name );\n";
    }
}

print hashline( __LINE__ ), << 'CODE';

  return 0;
}

int
control_mapping_init( void *context )
{
  /* Current settings as defaults for control mapping */
  control_mapping_copy_from_settings( &control_mapping_default, &settings_current );

  defaultmapfile = get_mapping_filename( DEFAULT_MAPPING_FILE );
  if ( settings_current.control_mapping_per_game && !settings_current.control_mapping_not_detached_defaults ) {
    if ( defaultmapfile ) {
      /* Read default config file. If it doesn't exist create it */
      if ( compat_file_exists( defaultmapfile ) ) {
        control_mapping_read_config_file( &control_mapping_default, defaultmapfile );
        control_mapping_copy_to_settings( &settings_current, &control_mapping_default );
      } else
        control_mapping_write_config( &control_mapping_default, defaultmapfile ) ;
    }
  }

  /* Stablish defaults as current control mapping */
  control_mapping_defaults( &control_mapping_current );
  control_mapping_copy( &control_mapping_default_old, &control_mapping_default );

  /* Save actual settings for detect changes for control mapping */
  settings_copy( &settings_old, &settings_current );

  ui_menu_activate( UI_MENU_ITEM_JOYSTICKS_CONTROL_MAPPING, settings_current.control_mapping_per_game ? 1 : 0 );

  return 0;
}

static void
control_mapping_end( void )
{
  /* Control mapping per game and auto-save actives? */
  if( settings_current.control_mapping_per_game && settings_current.control_mapping_autosave ) {
    /* Save only if something changed or if don't exist mapfile yet */
    if( mapfile &&
        ( !compat_file_exists( mapfile ) ||
           control_mapping_something_changed( &control_mapping_current, &settings_current ) ) ) {
      control_mapping_copy_from_settings( &control_mapping_current, &settings_current );
      control_mapping_write_config( &control_mapping_current, mapfile );
    }
    /* Save to defaults if detached defaults */
    if ( !settings_current.control_mapping_not_detached_defaults )
      control_mapping_write_config( &control_mapping_default, defaultmapfile );
  }

  /* 
     Restore default settings if not checked last mapping as default.
     If autosave is activated then settings_end will not save the last 
     control mapping loaded
  */
  if ( settings_current.control_mapping_per_game && !settings_current.control_mapping_not_detached_defaults )
    control_mapping_copy_to_settings( &settings_current, &control_mapping_default );

  /* Free stuff */
  control_mapping_free( &control_mapping_current );
  control_mapping_free( &control_mapping_default );
  control_mapping_free( &control_mapping_default_old );
  if ( mapfile ) libspectrum_free( mapfile );

#ifdef HAVE_LIB_XML2
  xmlCleanupParser();
#endif				/* #ifdef HAVE_LIB_XML2 */
}

void
control_mapping_register_startup( void )
{
  /* control_mapping_init not yet managed by the startup manager */

  startup_manager_module dependencies[] = {
  /* Fuse for OS X requires that settings_end is called before memory is
     deallocated as settings need to look up machine names etc */
    /* STARTUP_MANAGER_MODULE_MEMORY, */
    STARTUP_MANAGER_MODULE_SETTINGS_END,
    STARTUP_MANAGER_MODULE_SETUID
  };
  startup_manager_register( STARTUP_MANAGER_MODULE_CONTROL_MAPPING_END, dependencies,
                            ARRAY_SIZE( dependencies ), control_mapping_init, NULL,
                            control_mapping_end );
}

char*
get_mapping_filename( const char* filename )
{
  const char* cfgdir;
  char buffer[ PATH_MAX ];
  char* filename_test;

  if ( !filename ) return NULL;

  /* Don't exist config path, no error but do nothing */
  cfgdir = compat_get_config_path(); if( !cfgdir ) return NULL;

  if ( settings_current.control_mapping_no_transform_filename )
    filename_test = utils_last_filename( filename, 1 );
  else
    filename_test = compat_chop_expressions( re_expressions, utils_last_filename( filename, 1 ) );

  snprintf( buffer, PATH_MAX, "%s"FUSE_DIR_SEP_STR"%s"FUSE_DIR_SEP_STR"%s%s",
            cfgdir, "mappings", filename_test, ".fcm" );

  libspectrum_free( filename_test );

  return utils_safe_strdup( buffer );
}

CODE
